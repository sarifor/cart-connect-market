# HOW-IT-WORKS.md — Cart Connect Market

> "장바구니를 공유하면, 취향이 연결된다."

---

## 이 프로젝트는 뭘 하는 건가요?

Cart Connect Market(이하 CCM)은 **소셜 쇼핑 플랫폼**입니다. 20~30대 1인 가구를 타깃으로 만들어졌고, 핵심 아이디어는 간단합니다:

1. 물건을 주문한다.
2. 그 주문 내역을 "공개 장바구니(Public Cart)"로 공유한다.
3. 다른 사람의 공개 장바구니를 구경하고, 좋아요를 누르고, 마음에 들면 통째로 내 장바구니에 복사한다.
4. 좋아요 관계를 기반으로 **네트워크 그래프**가 그려진다 — 취향이 비슷한 사람끼리 연결되는 것이다.

마트에서 다른 사람 카트를 슬쩍 참고하는 그 심리, 그걸 온라인으로 옮긴 겁니다.

---

## 기술 스택 한눈에 보기

| 영역 | 기술 | 왜 이걸 골랐나 |
|------|------|----------------|
| **프론트엔드** | Next.js 15 + React 18 | 파일 기반 라우팅으로 빠른 개발, SSR 지원 |
| **상태 관리** | Redux Toolkit + Redux-Saga | 비동기 흐름을 제너레이터로 선언적으로 관리 |
| **UI 라이브러리** | Ant Design 5 | 테이블, 폼, 버튼 등 엔터프라이즈급 컴포넌트 |
| **네트워크 시각화** | vis-network | 그래프 노드/엣지 렌더링에 성숙한 라이브러리 |
| **백엔드** | Express.js | 가볍고 유연한 Node.js 웹 프레임워크 |
| **ORM** | Sequelize 6 | 모델 정의, 관계 설정, 마이그레이션을 코드로 관리 |
| **데이터베이스** | MySQL 8.4 | ACID 트랜잭션 보장 — 주문/결제에 필수 |
| **인증** | express-session + bcrypt | 서버사이드 세션 + 비밀번호 해싱 |

---

## 프로젝트 구조

```
cart-connect-market/
├── front/                    # 프론트엔드 (Next.js, 포트 3000)
│   ├── src/
│   │   ├── pages/            # 페이지 (파일 기반 라우팅)
│   │   ├── components/       # React 컴포넌트
│   │   ├── reducers/         # Redux 슬라이스
│   │   ├── sagas/            # Redux-Saga (비동기 로직)
│   │   └── store/            # 스토어 설정
│   └── __tests__/            # Jest 테스트
│
├── back/                     # 백엔드 (Express, 포트 4000)
│   ├── controllers/          # 비즈니스 로직
│   ├── routes/               # API 라우트 정의
│   ├── config/               # DB 설정 + 모델/관계
│   ├── migrations/           # Sequelize 마이그레이션
│   ├── sqls/                 # 더미 데이터 SQL
│   └── scripts/              # SQL 실행 스크립트
```

프론트와 백이 **완전히 분리**되어 있습니다. 프론트는 3000번 포트, 백은 4000번 포트에서 각각 돌아가고, CORS 설정으로 통신합니다. 이 구조의 장점은 명확합니다: 프론트 개발자와 백엔드 개발자가 서로 안 건드려도 되고, 배포도 독립적으로 할 수 있습니다.

---

## 데이터베이스: 10개의 테이블이 만드는 세계

CCM의 데이터베이스는 10개 테이블로 구성됩니다. 관계를 따라가면 비즈니스 로직이 보입니다:

```
Member ──┬── ShippingAddress    (1:N)  배송지 여러 개 저장 가능
         ├── Cart               (1:N)  장바구니 아이템
         ├── Order ── OrderDetail ── Product   주문 → 주문상세 → 상품
         ├── PublicCart          (1:N)  공개 장바구니 (Order와 1:1)
         └── Like               (1:N)  좋아요 (PublicCart와 N:1)

Category ── Product ── ProductImage
(자기 참조: 부모-자식 카테고리 트리)
```

### 설계에서 주목할 점

**Soft Delete (소프트 삭제)**: Member, Order, PublicCart는 `paranoid: true`로 설정되어 있습니다. 삭제해도 DB에서 실제로 지워지지 않고 `deleted_at` 타임스탬프만 찍힙니다. 회원이 탈퇴해도 주문 이력은 남아야 하니까요.

**Cascade Delete (연쇄 삭제)**: 반면 Cart와 OrderDetail은 부모가 삭제되면 같이 사라집니다. 장바구니 아이템은 히스토리를 보존할 필요가 없으니까요.

**Unique Index로 중복 좋아요 방지**: Like 테이블에 `(member_id, public_cart_id)` 유니크 인덱스가 걸려 있습니다. 같은 사람이 같은 공개 장바구니에 좋아요를 두 번 누르는 걸 DB 레벨에서 막습니다. 애플리케이션 코드에서만 체크하면 레이스 컨디션에 취약해지거든요.

---

## 백엔드 API: 요청이 흘러가는 길

### 주요 엔드포인트

| 경로 | 메서드 | 하는 일 |
|------|--------|---------|
| `/member/login` | POST | 이메일/비밀번호 로그인 |
| `/member/signup` | POST | 회원가입 + 기본 배송지 생성 |
| `/product/category/:id` | GET | 카테고리별 상품 조회 (하위 카테고리 재귀 포함) |
| `/product/top-selling` | GET | 베스트셀러 8개 (윈도우 함수 사용) |
| `/cart/add` | POST | 장바구니에 추가 (이미 있으면 수량 +1) |
| `/cart/copy` | POST | 공개 장바구니 → 내 장바구니로 복사 |
| `/checkout` | POST | 주문 생성 (트랜잭션) |
| `/public-cart` | POST | 주문을 공개 장바구니로 발행 |
| `/public-cart/network` | GET | 좋아요 기반 네트워크 그래프 데이터 |
| `/public-cart/:id/like` | PATCH | 좋아요 토글 |

### 트랜잭션이 중요한 곳

세 군데서 **수동 트랜잭션**을 사용합니다:

1. **checkout (결제)**: Order 생성 → OrderDetail 생성 → Cart 비우기. 이 세 단계 중 하나라도 실패하면 전부 롤백됩니다. 돈은 빠졌는데 주문이 안 만들어지는 최악의 시나리오를 막는 겁니다.

2. **copyCart (장바구니 복사)**: 공개 장바구니의 아이템들을 내 장바구니로 복사합니다. 이미 있는 상품은 수량을 합치고, 없는 상품은 새로 추가합니다. 하나라도 실패하면 전부 롤백.

3. **postPublicCart (공개 장바구니 발행)**: PublicCart 생성 → OrderDetail에 public_cart_id 연결. 원자적이어야 합니다.

비유하자면, 트랜잭션은 "전부 아니면 전무" 계약서입니다. 반만 실행된 주문이란 있을 수 없으니까요.

---

## 프론트엔드 상태 관리: Redux + Redux-Saga

### 왜 Redux-Saga인가?

Redux-Saga는 **제너레이터 함수**로 비동기 흐름을 관리합니다. 콜백 지옥도 없고, Promise 체인도 없습니다. API 호출, 로딩 상태 관리, 에러 처리가 읽기 쉬운 동기식 코드처럼 보입니다.

```javascript
// sagas/cart.js — 장바구니에 아이템 추가하는 사가
function* addToCart(action) {
  try {
    const result = yield call(axios.post, `${backURL}/cart/add`, action.data, { withCredentials: true });
    yield put({ type: ADD_TO_CART_SUCCESS, data: result.data });
  } catch (err) {
    yield put({ type: ADD_TO_CART_FAILURE, error: err.response.data });
  }
}
```

`yield`가 나올 때마다 실행이 멈추고, 비동기 작업이 끝나면 다시 이어집니다. 마치 책을 읽다가 북마크를 끼워두고, 나중에 이어 읽는 것과 같습니다.

### 상태 구조

```
Redux Store
├── member    → 로그인 상태, 사용자 정보
├── product   → 상품 목록, 카테고리, 베스트셀러
├── cart      → 장바구니 아이템
├── publicCart → 공개 장바구니 목록, 네트워크 데이터
├── order     → 주문 내역
└── checkout  → 결제 진행 상태
```

모든 비동기 작업에 **삼중 상태 패턴**(loading / done / error)이 적용되어 있습니다. `addToCartLoading`, `addToCartDone`, `addToCartError` — 이 세 가지로 UI가 "로딩 중", "완료", "실패" 상태를 정확히 반영합니다.

---

## 핵심 기능: 네트워크 시각화

이 프로젝트에서 가장 흥미로운 부분은 **좋아요 관계를 기반으로 한 네트워크 그래프**입니다.

### 알고리즘 (back/controllers/public-cart.js)

1. **Step 1**: 로그인한 사용자가 최근에 좋아요한 공개 장바구니 3개를 시간순으로 연결합니다. (내가 어떤 경로로 취향을 탐색했는지 보여줌)

2. **Step 2**: 같은 공개 장바구니를 좋아요한 최근 2명의 사용자를 찾아서 연결합니다. (취향이 겹치는 사람들끼리 묶어줌)

3. **Step 3**: 각 노드에 라벨을 생성합니다. 공개 장바구니의 제목과 작성자 정보가 포함됩니다.

4. **Step 4**: 로그인한 사용자가 가장 최근에 좋아요한 장바구니 ID를 반환합니다. 프론트엔드에서 이 노드를 별표(★)로 강조합니다.

### 프론트엔드 렌더링 (NetworkView.js)

vis-network 라이브러리로 그래프를 그립니다. 여기서 중요한 건 **메모리 누수 방지**입니다:

```javascript
useEffect(() => {
  // vis-network 인스턴스 생성
  const network = new Network(container, data, options);

  return () => {
    // 컴포넌트 언마운트 시 반드시 파괴
    network.destroy();
  };
}, []);
```

React에서 외부 라이브러리 인스턴스를 사용할 때 cleanup을 안 하면, 페이지를 오갈 때마다 인스턴스가 쌓이면서 메모리가 샙니다. 수도꼭지를 안 잠그고 나가는 것과 같습니다.

---

## 인증 시스템: 세션과 쿠키

CCM은 **서버사이드 세션** 방식을 사용합니다. JWT가 아니라 express-session입니다.

### 흐름

1. 사용자가 이메일/비밀번호로 로그인
2. bcrypt로 비밀번호 검증 (salt rounds: 12)
3. 검증 성공 → 서버에 세션 생성, 클라이언트에 세션 쿠키 전송
4. 이후 모든 요청에 쿠키가 자동으로 포함됨
5. 로그아웃 → 서버 세션 파괴 + 쿠키 삭제

### CORS + Credentials: 이 프로젝트의 최대 함정

프론트(3000포트)와 백(4000포트)이 다른 포트에서 돌아가므로 **크로스 오리진** 문제가 발생합니다. 해결법:

- **백엔드**: `cors({ origin: 'http://localhost:3000', credentials: true })`
- **프론트엔드**: 모든 axios 요청에 `{ withCredentials: true }`

이걸 하나라도 빠뜨리면 쿠키가 전송되지 않아서 로그인이 안 됩니다. 로그아웃도 마찬가지 — `withCredentials: true` 없이 로그아웃 요청을 보내면 서버가 "이 사람 누구?" 하면서 세션을 못 찾습니다.

프로덕션에서는 `domain: '.sarifor.net'`으로 설정해서 서브도메인 간 쿠키 공유를 합니다. `ccm.sarifor.net`(프론트)과 `ccm-api.sarifor.net`(백)이 같은 쿠키를 공유하는 것입니다.

---

## 쇼핑 플로우: 처음부터 끝까지

```
[로그인] → [카테고리 선택] → [상품 목록] → [장바구니에 추가]
    ↓
[장바구니 확인] → [결제 폼 작성] → [주문 리뷰]
    ↓
[주문 완료] → [주문 내역에서 "공개하기"] → [공개 장바구니 생성]
    ↓
[다른 유저] → [공개 장바구니 목록] → [좋아요 / 내 장바구니로 복사]
    ↓
[네트워크 그래프에서 취향 연결 확인]
```

### 배송비 계산 로직

- 상품 합계가 2,000원 이상 → 배송비 무료
- 2,000원 미만 → 배송비 200원
- 세금: 10% (소비세)

---

## 배포 환경

| 환경 | 프론트 | 백엔드 | DB |
|------|--------|--------|-----|
| **개발** | localhost:3000 | localhost:4000 | mysql_ccm_dev |
| **프로덕션** | ccm.sarifor.net (포트 3060) | ccm-api.sarifor.net (포트 3065) | mysql_ccm_prod |

프로덕션에서는 **PM2**로 프로세스를 관리합니다. PM2는 Node.js 프로세스 매니저로, 앱이 죽으면 자동으로 재시작해주고, 로그 관리도 해줍니다.

---

## 버그와 함정: 실전에서 배운 것들

### 1. CORS + withCredentials 문제

**증상**: 로그인은 되는데, 다른 API 호출에서 "로그인 안 됨" 응답이 온다.

**원인**: axios 요청에 `withCredentials: true`를 빠뜨렸다. 쿠키가 안 날아가니 서버가 세션을 못 찾는 것.

**교훈**: 크로스 오리진 환경에서 세션 기반 인증을 쓸 때는, **모든** 요청에 credentials를 포함해야 합니다. 하나라도 빠지면 그 요청만 비로그인 상태가 됩니다.

### 2. vis-network 메모리 누수

**증상**: 네트워크 페이지를 오갈수록 브라우저가 느려진다.

**원인**: React 컴포넌트가 언마운트될 때 vis-network 인스턴스를 파괴하지 않았다.

**교훈**: 외부 라이브러리로 DOM을 직접 조작하는 컴포넌트는 반드시 `useEffect`의 cleanup 함수에서 인스턴스를 정리해야 합니다.

### 3. useEffect 이중 실행 (React Strict Mode)

**증상**: 개발 모드에서 API가 두 번 호출된다.

**원인**: React 18의 Strict Mode가 컴포넌트를 마운트 → 언마운트 → 재마운트합니다.

**해결**: `useRef`로 이미 실행했는지 추적하는 가드를 넣었습니다.

### 4. Sequelize 관계 정의 순서

**증상**: 모델 간 관계가 제대로 안 잡힌다.

**원인**: 부모 모델보다 자식 모델을 먼저 정의하면 외래 키를 못 찾는다.

**교훈**: Sequelize에서 관계를 정의할 때는 항상 **참조되는 쪽(부모)을 먼저** 정의해야 합니다.

### 5. 좋아요 토글의 레이스 컨디션

**증상**: 빠르게 좋아요를 연타하면 중복 레코드가 생길 수 있다.

**해결**: DB에 `(member_id, public_cart_id)` 유니크 인덱스를 걸어서 DB 레벨에서 방지. 이미 레코드가 있으면 `status`만 토글(1↔0)합니다.

**교훈**: 데이터 무결성은 애플리케이션 코드가 아니라 데이터베이스에서 보장하는 것이 원칙입니다.

---

## 좋은 엔지니어가 이 코드에서 보여주는 것들

### 1. 관심사의 분리

프론트엔드: `pages`(라우팅) → `components`(UI) → `reducers`(상태) → `sagas`(비동기)
백엔드: `routes`(경로) → `controllers`(로직) → `config/db.js`(데이터)

각 레이어가 자기 역할만 합니다. 사가에서 직접 UI를 건드리지 않고, 컨트롤러에서 라우트를 정의하지 않습니다.

### 2. 방어적 프로그래밍

- 트랜잭션으로 데이터 일관성 보장
- Soft delete로 데이터 보존
- 유니크 인덱스로 중복 방지
- 비밀번호 해싱 (bcrypt, salt 12라운드)
- httpOnly 쿠키로 XSS 방어

### 3. 사용자 경험을 위한 디테일

- 장바구니에 같은 상품을 추가하면 수량만 +1 (중복 아이템 안 생김)
- 공개 장바구니 복사 시 이미 있는 상품은 수량 합산
- 모든 비동기 작업에 로딩/성공/실패 상태 → UI에서 스피너, 성공 메시지, 에러 메시지 표시 가능

### 4. 재귀적 사고

카테고리 시스템이 트리 구조입니다. "식품" 카테고리를 선택하면 "과일", "채소", "유제품" 등 하위 카테고리의 상품까지 전부 보여줍니다. 이걸 재귀 함수로 처리합니다:

```
식품 (level 1)
├── 과일 (level 2) → 사과, 바나나
├── 채소 (level 2) → 당근, 양파
└── 유제품 (level 2) → 우유, 치즈
```

상위 카테고리 하나를 클릭하면, 코드가 트리를 타고 내려가면서 모든 자식 카테고리의 ID를 수집하고, 그 ID들에 해당하는 상품을 한 번에 조회합니다.

---

## 마무리

Cart Connect Market은 단순한 쇼핑몰이 아닙니다. **쇼핑 행위 자체를 소셜 경험으로 바꾸는 실험**입니다. 기술적으로는 풀스택 웹 애플리케이션의 교과서적인 구조를 따르면서도, 네트워크 시각화라는 독특한 기능으로 차별화됩니다.

이 프로젝트에서 가장 중요한 교훈이 있다면:

> **복잡한 시스템은 단순한 부품의 조합이다.**

10개의 테이블, 6개의 Redux 슬라이스, 6개의 사가, 6개의 컨트롤러 — 각각은 단순하지만, 조합하면 "장바구니를 공유하고, 취향을 시각화하는" 복잡한 경험이 만들어집니다.

좋은 소프트웨어는 복잡한 코드가 아니라, **단순한 코드의 좋은 조합**으로 만들어집니다.
