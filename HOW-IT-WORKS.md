# HOW-IT-WORKS.md — Cart Connect Market <!-- omit in toc -->

「カートを共有すれば、好みがつながる。」

----

## 目次 <!-- omit in toc -->

- [このプロジェクトは何をするの？](#このプロジェクトは何をするの)
- [技術スタック一覧](#技術スタック一覧)
- [プロジェクト構成](#プロジェクト構成)
- [データベース：10個のテーブルが作り上げる世界](#データベース10個のテーブルが作り上げる世界)
  - [設計で注目すべきポイント](#設計で注目すべきポイント)
- [バックエンドAPI：リクエストが流れる道](#バックエンドapiリクエストが流れる道)
  - [主要エンドポイント](#主要エンドポイント)
  - [トランザクションが重要な場所](#トランザクションが重要な場所)
- [フロントエンド状態管理：Redux + Redux-Saga](#フロントエンド状態管理redux--redux-saga)
  - [なぜRedux-Sagaなのか？](#なぜredux-sagaなのか)
  - [状態構造](#状態構造)
- [コア機能：ネットワーク可視化](#コア機能ネットワーク可視化)
  - [アルゴリズム (back/controllers/public-cart.js)](#アルゴリズム-backcontrollerspublic-cartjs)
  - [フロントエンド描画 (NetworkView.js)](#フロントエンド描画-networkviewjs)
- [認証システム：セッションとCookie](#認証システムセッションとcookie)
  - [フロー](#フロー)
  - [CORS + Credentials：このプロジェクト最大の落とし穴](#cors--credentialsこのプロジェクト最大の落とし穴)
- [ショッピングフロー：最初から最後まで](#ショッピングフロー最初から最後まで)
  - [送料計算ロジック](#送料計算ロジック)
- [デプロイ環境](#デプロイ環境)
- [バグと落とし穴：実戦で学んだこと](#バグと落とし穴実戦で学んだこと)
  - [1. CORS + withCredentials問題](#1-cors--withcredentials問題)
  - [2. vis-networkメモリリーク](#2-vis-networkメモリリーク)
  - [3. useEffect二重実行（React Strict Mode）](#3-useeffect二重実行react-strict-mode)
  - [4. Sequelizeリレーション定義の順序](#4-sequelizeリレーション定義の順序)
  - [5. いいねトグルのレースコンディション](#5-いいねトグルのレースコンディション)
- [優れたエンジニアがこのコードで示していること](#優れたエンジニアがこのコードで示していること)
  - [1. 関心の分離](#1-関心の分離)
  - [2. 防御的プログラミング](#2-防御的プログラミング)
  - [3. ユーザー体験のためのこだわり](#3-ユーザー体験のためのこだわり)
  - [4. 再帰的思考](#4-再帰的思考)
- [おわりに](#おわりに)


---

## このプロジェクトは何をするの？

Cart Connect Market（以下CCM）は**ソーシャルショッピングプラットフォーム**です。20〜30代の一人暮らし世帯をターゲットに作られており、コアとなるアイデアはシンプルです：

1. 商品を注文する。
2. その注文履歴を「公開カート（Public Cart）」として共有する。
3. 他の人の公開カートを眺めて、いいねを押して、気に入ったらまるごと自分のカートにコピーする。
4. いいねの関係をもとに**ネットワークグラフ**が描かれる — 好みが似ている人同士がつながる。

スーパーで他の人のカートをちらっと覗いてしまう、あの心理。それをオンラインに持ってきたわけです。

---

## 技術スタック一覧

| 領域 | 技術 | なぜこれを選んだのか |
|------|------|----------------------|
| **フロントエンド** | Next.js 15 + React 18 | ファイルベースルーティングで高速開発、SSR対応 |
| **状態管理** | Redux Toolkit + Redux-Saga | 非同期フローをジェネレーターで宣言的に管理 |
| **UIライブラリ** | Ant Design 5 | テーブル、フォーム、ボタンなどエンタープライズ級コンポーネント |
| **ネットワーク可視化** | vis-network | グラフのノード/エッジ描画に特化したライブラリ |
| **バックエンド** | Express.js | 軽量で柔軟なNode.jsウェブフレームワーク |
| **ORM** | Sequelize 6 | モデル定義、リレーション設定、マイグレーションをコードで管理 |
| **データベース** | MySQL 8.4 | ACIDトランザクション保証 — 注文/決済に必須 |
| **認証** | express-session + bcrypt | サーバーサイドセッション + パスワードハッシュ化 |

---

## プロジェクト構成

```
cart-connect-market/
├── front/                    # フロントエンド (Next.js, ポート3000)
│   ├── src/
│   │   ├── pages/            # ページ (ファイルベースルーティング)
│   │   ├── components/       # Reactコンポーネント
│   │   ├── reducers/         # Reduxスライス
│   │   ├── sagas/            # Redux-Saga (非同期ロジック)
│   │   └── store/            # ストア設定
│   └── __tests__/            # Jestテスト
│
├── back/                     # バックエンド (Express, ポート4000)
│   ├── controllers/          # ビジネスロジック
│   ├── routes/               # APIルート定義
│   ├── config/               # DB設定 + モデル/リレーション
│   ├── migrations/           # Sequelizeマイグレーション
│   ├── sqls/                 # ダミーデータSQL
│   └── scripts/              # SQL実行スクリプト
```

フロントとバックは**完全に分離**されています。フロントは3000番ポート、バックは4000番ポートでそれぞれ動作し、CORS設定で通信します。この構成のメリットは明確です：フロント開発者とバックエンド開発者がお互いのコードに触れずに済み、デプロイも独立して行えます。

---

## データベース：10個のテーブルが作り上げる世界

CCMのデータベースは10個のテーブルで構成されています。リレーションをたどると、ビジネスロジックが見えてきます：

```
Member ──┬── ShippingAddress    (1:N)  配送先を複数保存可能
         ├── Cart               (1:N)  カートアイテム
         ├── Order ── OrderDetail ── Product   注文 → 注文明細 → 商品
         ├── PublicCart          (1:N)  公開カート (Orderと1:1)
         └── Like               (1:N)  いいね (PublicCartとN:1)

Category ── Product ── ProductImage
(自己参照：親子カテゴリツリー)
```

### 設計で注目すべきポイント

**Soft Delete（論理削除）**：Member、Order、PublicCartには`paranoid: true`が設定されています。削除してもDBから実際には消えず、`deleted_at`タイムスタンプが記録されるだけです。会員が退会しても注文履歴は残さなければならないからです。

**Cascade Delete（連鎖削除）**：一方、CartとOrderDetailは親が削除されると一緒に消えます。カートアイテムは履歴を保持する必要がないからです。

**Unique Indexで重複いいねを防止**：Likeテーブルに`(member_id, public_cart_id)`のユニークインデックスが設定されています。同じ人が同じ公開カートに2回いいねを押すのを、DBレベルで防いでいます。アプリケーションコードだけでチェックすると、レースコンディションに弱くなるからです。

---

## バックエンドAPI：リクエストが流れる道

### 主要エンドポイント

| パス | メソッド | やること |
|------|----------|----------|
| `/member/login` | POST | メール/パスワードログイン |
| `/member/signup` | POST | 会員登録 + デフォルト配送先作成 |
| `/product/category/:id` | GET | カテゴリ別商品取得（サブカテゴリの再帰込み） |
| `/product/top-selling` | GET | ベストセラー8件（ウィンドウ関数使用） |
| `/cart/add` | POST | カートに追加（既にあれば数量+1） |
| `/cart/copy` | POST | 公開カート → 自分のカートにコピー |
| `/checkout` | POST | 注文作成（トランザクション） |
| `/public-cart` | POST | 注文を公開カートとして発行 |
| `/public-cart/network` | GET | いいねベースのネットワークグラフデータ |
| `/public-cart/:id/like` | PATCH | いいねトグル |

### トランザクションが重要な場所

3箇所で**手動トランザクション**を使用しています：

1. **checkout（決済）**：Order作成 → OrderDetail作成 → Cart削除。この3ステップのうち1つでも失敗したら全てロールバックされます。お金は引かれたのに注文が作られない、という最悪のシナリオを防ぐためです。

2. **copyCart（カートコピー）**：公開カートのアイテムを自分のカートにコピーします。既にある商品は数量を合算し、ない商品は新規追加します。1つでも失敗したら全てロールバック。

3. **postPublicCart（公開カート発行）**：PublicCart作成 → OrderDetailにpublic_cart_idを紐付け。アトミックでなければなりません。

たとえるなら、トランザクションは「全か無か」の契約書です。半分だけ実行された注文なんて、あってはならないのです。

---

## フロントエンド状態管理：Redux + Redux-Saga

### なぜRedux-Sagaなのか？

Redux-Sagaは**ジェネレーター関数**で非同期フローを管理します。コールバック地獄もなければ、Promiseチェーンもありません。API呼び出し、ローディング状態管理、エラー処理が、読みやすい同期コードのように見えます。

```javascript
// sagas/cart.js — カートにアイテムを追加するSaga
function* addToCart(action) {
  try {
    const result = yield call(axios.post, `${backURL}/cart/add`, action.data, { withCredentials: true });
    yield put({ type: ADD_TO_CART_SUCCESS, data: result.data });
  } catch (err) {
    yield put({ type: ADD_TO_CART_FAILURE, error: err.response.data });
  }
}
```

`yield`が出てくるたびに実行が一時停止し、非同期処理が完了したら再開されます。まるで本を読んでいる途中でしおりを挟んで、後からまた続きを読むようなものです。

### 状態構造

```
Redux Store
├── member    → ログイン状態、ユーザー情報
├── product   → 商品一覧、カテゴリ、ベストセラー
├── cart      → カートアイテム
├── publicCart → 公開カート一覧、ネットワークデータ
├── order     → 注文履歴
└── checkout  → 決済進行状態
```

すべての非同期処理に**三重状態パターン**（loading / done / error）が適用されています。`addToCartLoading`、`addToCartDone`、`addToCartError` — この3つでUIが「読み込み中」「完了」「失敗」の状態を正確に反映します。

---

## コア機能：ネットワーク可視化

このプロジェクトで最も面白い部分は、**いいね関係にもとづくネットワークグラフ**です。

### アルゴリズム (back/controllers/public-cart.js)

1. **Step 1**：ログインユーザーが最近いいねした公開カート3つを時系列順につなげます。（どんな経路で好みを探索したかを可視化）

2. **Step 2**：同じ公開カートにいいねした直近2名のユーザーを見つけてつなげます。（好みが重なる人同士をグルーピング）

3. **Step 3**：各ノードにラベルを生成します。公開カートのタイトルと作成者情報が含まれます。

4. **Step 4**：ログインユーザーが最も直近にいいねしたカートIDを返します。フロントエンドではこのノードを星マーク（★）で強調表示します。

### フロントエンド描画 (NetworkView.js)

vis-networkライブラリでグラフを描画します。ここで重要なのは**メモリリーク防止**です：

```javascript
useEffect(() => {
  // vis-networkインスタンスを作成
  const network = new Network(container, data, options);

  return () => {
    // コンポーネントのアンマウント時に必ず破棄
    network.destroy();
  };
}, []);
```

Reactで外部ライブラリのインスタンスを使う際にクリーンアップしないと、ページを行き来するたびにインスタンスが積み上がってメモリが漏れます。蛇口を閉めずに出ていくのと同じです。

---

## 認証システム：セッションとCookie

CCMは**サーバーサイドセッション**方式を採用しています。JWTではなくexpress-sessionです。

### フロー

1. ユーザーがメール/パスワードでログイン
2. bcryptでパスワード検証（salt rounds: 12）
3. 検証成功 → サーバーにセッション作成、クライアントにセッションCookieを送信
4. 以降すべてのリクエストにCookieが自動で含まれる
5. ログアウト → サーバーセッション破棄 + Cookie削除

### CORS + Credentials：このプロジェクト最大の落とし穴

フロント（3000番ポート）とバック（4000番ポート）が異なるポートで動作するため、**クロスオリジン**の問題が発生します。解決策：

- **バックエンド**：`cors({ origin: 'http://localhost:3000', credentials: true })`
- **フロントエンド**：すべてのaxiosリクエストに`{ withCredentials: true }`

これを1つでも忘れると、Cookieが送信されずログインできません。ログアウトも同様です — `withCredentials: true`なしでログアウトリクエストを送ると、サーバーは「この人誰？」となってセッションを見つけられません。

本番環境では`domain: '.sarifor.net'`に設定して、サブドメイン間でCookieを共有しています。`ccm.sarifor.net`（フロント）と`ccm-api.sarifor.net`（バック）が同じCookieを共有するわけです。

---

## ショッピングフロー：最初から最後まで

```
[ログイン] → [カテゴリ選択] → [商品一覧] → [カートに追加]
    ↓
[カート確認] → [決済フォーム入力] → [注文レビュー]
    ↓
[注文完了] → [注文履歴から「公開する」] → [公開カート作成]
    ↓
[他のユーザー] → [公開カート一覧] → [いいね / 自分のカートにコピー]
    ↓
[ネットワークグラフで好みのつながりを確認]
```

### 送料計算ロジック

- 商品合計が2,000円以上 → 送料無料
- 2,000円未満 → 送料200円
- 税金：10%（消費税）

---

## デプロイ環境

| 環境 | フロント | バックエンド | DB |
|------|----------|-------------|-----|
| **開発** | localhost:3000 | localhost:4000 | mysql_ccm_dev |
| **本番** | ccm.sarifor.net (ポート3060) | ccm-api.sarifor.net (ポート3065) | mysql_ccm_prod |

本番環境では**PM2**でプロセスを管理しています。PM2はNode.jsのプロセスマネージャーで、アプリが落ちたら自動で再起動してくれますし、ログ管理もやってくれます。

---

## バグと落とし穴：実戦で学んだこと

### 1. CORS + withCredentials問題

**症状**：ログインはできるのに、他のAPI呼び出しで「ログインしていません」というレスポンスが返ってくる。

**原因**：axiosリクエストに`withCredentials: true`を付け忘れた。Cookieが飛ばないのでサーバーがセッションを見つけられない。

**教訓**：クロスオリジン環境でセッションベース認証を使う場合、**すべての**リクエストにcredentialsを含める必要があります。1つでも漏れると、そのリクエストだけ未ログイン状態になります。

### 2. vis-networkメモリリーク

**症状**：ネットワークページを行き来するほどブラウザが重くなる。

**原因**：Reactコンポーネントがアンマウントされる際にvis-networkインスタンスを破棄していなかった。

**教訓**：外部ライブラリでDOMを直接操作するコンポーネントは、必ず`useEffect`のクリーンアップ関数でインスタンスを後片付けしなければなりません。

### 3. useEffect二重実行（React Strict Mode）

**症状**：開発モードでAPIが2回呼ばれる。

**原因**：React 18のStrict Modeがコンポーネントをマウント → アンマウント → 再マウントする。

**解決**：`useRef`で既に実行済みかどうかを追跡するガードを入れました。

### 4. Sequelizeリレーション定義の順序

**症状**：モデル間のリレーションがうまく設定されない。

**原因**：親モデルより子モデルを先に定義すると、外部キーを見つけられない。

**教訓**：Sequelizeでリレーションを定義する際は、必ず**参照される側（親）を先に**定義する必要があります。

### 5. いいねトグルのレースコンディション

**症状**：いいねを素早く連打すると重複レコードが発生する可能性がある。

**解決**：DBに`(member_id, public_cart_id)`のユニークインデックスを設定してDBレベルで防止。既にレコードが存在する場合は`status`だけをトグル（1↔0）します。

**教訓**：データ整合性はアプリケーションコードではなく、データベースで保証するのが原則です。

---

## 優れたエンジニアがこのコードで示していること

### 1. 関心の分離

フロントエンド：`pages`（ルーティング）→ `components`（UI）→ `reducers`（状態）→ `sagas`（非同期）
バックエンド：`routes`（経路）→ `controllers`（ロジック）→ `config/db.js`（データ）

各レイヤーが自分の役割だけを果たします。SagaからUIを直接触ることはなく、コントローラーでルートを定義することもありません。

### 2. 防御的プログラミング

- トランザクションでデータ一貫性を保証
- Soft Deleteでデータを保全
- ユニークインデックスで重複防止
- パスワードハッシュ化（bcrypt、salt 12ラウンド）
- httpOnly CookieでXSS対策

### 3. ユーザー体験のためのこだわり

- カートに同じ商品を追加すると数量だけ+1（重複アイテムは作らない）
- 公開カートのコピー時、既にある商品は数量を合算
- すべての非同期処理にローディング/成功/失敗の状態 → UIでスピナー、成功メッセージ、エラーメッセージを表示可能

### 4. 再帰的思考

カテゴリシステムはツリー構造です。「食品」カテゴリを選択すると、「果物」「野菜」「乳製品」などのサブカテゴリの商品まですべて表示されます。これを再帰関数で処理しています：

```
食品 (level 1)
├── 果物 (level 2) → りんご、バナナ
├── 野菜 (level 2) → にんじん、たまねぎ
└── 乳製品 (level 2) → 牛乳、チーズ
```

上位カテゴリを1つクリックすると、コードがツリーをたどりながらすべての子カテゴリのIDを収集し、そのIDに該当する商品を一括で取得します。

---

## おわりに

Cart Connect Marketは単なるネットショップではありません。**買い物という行為そのものをソーシャルな体験に変える実験**です。技術的にはフルスタックWebアプリケーションの教科書的な構成に従いながらも、ネットワーク可視化というユニークな機能で差別化しています。

このプロジェクトから得られる最も大切な教訓があるとすれば：

> **複雑なシステムは、シンプルな部品の組み合わせである。**

10個のテーブル、6つのReduxスライス、6つのSaga、6つのコントローラー — それぞれは単純ですが、組み合わせることで「カートを共有し、好みを可視化する」という複雑な体験が生まれます。

優れたソフトウェアは複雑なコードからではなく、**シンプルなコードの優れた組み合わせ**から生まれるのです。
